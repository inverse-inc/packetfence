# Copyright (C) Inverse inc.
[general]
#
# general.domain
#
# Domain name of PacketFence system.
domain=packetfence.org
#
# general.hostname
#
# Hostname of PacketFence system.  This is concatenated with the domain in Apache rewriting rules and therefore must be resolvable by clients.
hostname=packetfence
#
# general.dhcpservers
#
# Comma-delimited list of DHCP servers.  Passthroughs are created to allow DHCP transactions from even "trapped" nodes.
dhcpservers=127.0.0.1
# general.send_anonymous_stats
#
# Whether or not to send anonymous statistics on how you use PacketFence
send_anonymous_stats = enabled
#
# general.timezone
#
# System's timezone in string format. List generated from Perl library DateTime::TimeZone
# When left empty, it will use the timezone of the server
timezone=

[network]
#
# network.dhcpdetector
#
# If enabled, PacketFence will monitor DHCP-specific items such as rogue DHCP services, DHCP-based OS fingerprinting, computername/hostname 
# resolution, and (optionnally) option-82 location-based information.  The monitored DHCP packets are DHCPDISCOVERs and DHCPREQUESTs - both are broadcasts, 
# meaning a span port is not necessary.  This feature is highly recommended if the internal network is DHCP-based.
dhcpdetector=enabled
#
# network.dhcp_rate_limiting
#
# Will rate-limit DHCP packets that contain the same information.
# For example, a DHCPREQUEST for the same MAC/IP will only be processed once in the timeframe configured below.
# This is independant of the DHCP server/relay handling the packet and is only based on the IP, MAC Address and DHCP type inside the packet.
# A value of 0 will disable the rate limitation.
dhcp_rate_limiting=5s
#
# network.rogue_dhcp_detection
#
# Tries to identify Rogue DHCP Servers and triggers the 1100010 security_event if one is found.
# This feature is only available if the dhcpdetector is activated.
rogue_dhcp_detection=enabled
#
# network.rogueinterval
#
# When rogue DHCP server detection is enabled, this parameter defines how often to email administrators.  With its default 
# setting of 10, it will email administrators the details of the previous 10 DHCP offers.
rogueinterval=10
#
# network.hostname_change_detection
#
# Will identify hostname changes and send an e-mail with these changes.
# This can help detect MAC spoofing.
hostname_change_detection=disabled
#
# network.connection_type_change_detection
#
# Will identify if a device switches from wired to wireless (or the opposite) and send an e-mail with these changes.
# This can help detect MAC spoofing.
connection_type_change_detection=disabled
#
# network.dhcpoption82logger
#
# If enabled PacketFence will monitor DHCP option82 location-based information.
# This feature is only available if the dhcpdetector is activated.
dhcpoption82logger=disabled
#
# network.dhcp_filter_by_message_types
#
# Which dhcp message types are being listened by the pfdhcplistener.
# Do not change unless you know what you are doing
#Possibilities are: DHCPOFFER,DHCPREQUEST,DHCPDECLINE,DHCPACK,DHCPRELEASE
dhcp_filter_by_message_types=DHCPREQUEST,DHCPACK
#
# network.dhcp_process_ipv6
#
# Enable/disable ipv6 dhcp packets processing by pfdhcplistener.
dhcp_process_ipv6=enabled
#
# network.force_listener_update_on_ack
#
# This will only do the iplog update and other DHCP related task on a DHCPACK.
# You need to make sure the UDP reflector is in place so this works on the production network.
# This is implicitly activated on registration interfaces on which dhcpd runs.
force_listener_update_on_ack=disabled
#
# network.learn_network_cidr_by_role
#
# This will enable the learning of the networks tied to each roles on each switches by using the dhcp traffic and radius accounting.
# To act on DHCP ACK (that contain the netmask) you need to enable force_listener_on_ack otherwise PacketFence will try to detect the cidr network based on the minumum address and the maximum address.
learn_network_cidr_by_role=disabled
#
# network.interfaceSNAT
# Choose interface(s) where you want to enable snat for passthrough (by default it's the management interface)
interfaceSNAT=
#
# network.staticroutes
#
# This will add the static routes you defined here on the system (managed by keepalived)
staticroutes=

[fencing]
# 
# fencing.wait_for_redirect
#
# How many seconds should the WebAPI sleep before actually triggering the VLAN change.
# This is meant to give the device enough time to fetch the redirection page before 
# switching VLAN.
wait_for_redirect = 1
#
# fencing.whitelist
#
# Comma-delimited list of MAC addresses that are immune to isolation. In 
# inline level 2 enforcement, the firewall is opened for them as if they were 
# registered. This "feature" will probably be reworked in the future.
whitelist=
#
# fencing.range
#
# Comma-delimited list of address ranges/CIDR blocks that Snort/Suricata will monitor/detect/trap on.  Gateway, network, and 
# broadcast addresses are ignored.
range=
#
# fencing.passthrough
#
# When enabled, pfdns will resolve the real IP addresses of passthroughs and add them in the ipset session to give access
# to trapped devices. Don´t forget to enable ip_forward on your server.
passthrough=enabled
#
# fencing.passthroughs
#
# Comma-delimited list of domains to be used as HTTP and HTTPS passthroughs to web sites.
#
passthroughs=
#
# fencing.proxy_passthroughs
#
# Comma-delimited list of domains to be use for apache passthrough
proxy_passthroughs=crl.geotrust.com,ocsp.geotrust.com,crl.thawte.com,ocsp.thawte.com,crl.comodoca.com,ocsp.comodoca.com,crl.incommon.org,ocsp.incommon.org,crl.usertrust.com,ocsp.usertrust.com,mscrl.microsoft.com,crl.microsoft.com,ocsp.apple.com,ocsp.digicert.com,ocsp.entrust.com,srvintl-crl.verisign.com,ocsp.verisign.com,ctldl.windowsupdate.com,crl.globalsign.net,pki.google.com,www.microsoft.com,crl.godaddy.com,ocsp.godaddy.com,certificates.godaddy.com,crl.globalsign.com,secure.globalsign.com,cacerts.digicert.com,crt.comodoca.com,crl.incommon-rsa.org,crl.quovadisglobal.com,cert.incommon.org,crt.usertrust.com,crl.verisign.com,crl.starfieldtech.com,developer.apple.com,ts-crl.ws.symantec.com,certificates.intel.com,ocsp.sectigo.com
#
# fencing.isolation_passthrough
#
# When enabled, pfdns will resolve the real IP addresses of passthroughs and add them in the ipset session to give access
# to trapped devices. Don´t forget to enable ip_forward on your server.
isolation_passthrough=disabled
#
# fencing.isolation_passthroughs
#
# Comma-delimited list of domains to be used as HTTP and HTTPS passthroughs to web sites.
#
isolation_passthroughs=
#
# fencing.interception_proxy
#
# When enabled, packetfence will intercept proxy request to somes specified port
interception_proxy=disabled
#
# fencing.interception_proxy_port
#
# Comma-delimited list of port used to intercept proxy traffic
interception_proxy_port=8080,3128

[guests_admin_registration]
#
# guests_admin_registration.access_duration_choices
#
# These are all the choices offered in the guest management interface as 
# possible access duration values for a given registration.
access_duration_choices=1h,3h,12h,1D,2D,3D,5D
#
# guests_admin_registration.default_access_duration
#
# This is the default access duration value selected in the dropdown on the 
# guest management interface.
default_access_duration=12h

[alerting]
#
# alerting.emailaddr
#
# Comma-delimited list of email addresses to which notifications of rogue DHCP servers, security_events with an action of "email", or any other
# PacketFence-related message goes to.
emailaddr=pf@localhost
#
# alerting.fromaddr
#
# Source email address for email notifications. Empty means root@<server-domain-name>.
fromaddr=
#
# alerting.smtpserver
#
# Server through which to send messages to the above emailaddr.  The default is localhost - be sure you're running an SMTP 
# host locally if you don't change it!
smtpserver=localhost
#
# alerting.subjectprefix
#
#Subject prefix for email notifications of rogue DHCP servers, security_events with an action of "email", or any other
#PacketFence-related message.
subjectprefix=PF Alert:
#
# alerting.smtp_encryption
#
# Encryption style when connecting to the SMTP server.
smtp_encryption=none
#
# alerting.smtp_port
#
# The port of the SMTP server.
# If the port is set to 0 then port is calculated by the encryption type.
# none:25, ssl:465, starttls:587
smtp_port=0
#
# alerting.smtp_username
#
# The username used to connect to the SMTP server
smtp_username=
#
# alerting.smtp_password
#
# The password used to connect to the SMTP server
smtp_password=
#
# alerting.smtp_verify_ssl
#
# Verify SSL connection
smtp_verifyssl=enabled
#
# alerting.smtp_timeout
#
# The timeout in seconds for sending an email
smtp_timeout=20

[ports]
#
# ports.admin
#
# Port the administrative interface listens on.
admin=1443
#
# ports.soap
#
# Port of the soap interface listens on.
soap=9090
#
# ports.collector
#
# Port of the collector interface listens on.
collector=9292
#
# ports.aaa
#
# Port of the aaa http interface listens on.
aaa=7070
#
# ports.httpd_portal_modstatus
#
# Port the mod_status for httpd.portal listens on.
httpd_portal_modstatus=1444
#
# ports.unified_api
#
# port to use for accessing the Unified API
unifiedapi=9999
#
# ports.pfacct_netflow
#
# port for listening to netflow
pfacct_netflow=2056

[database]
#
# database.host
#
# Server the MySQL server is running on.
host=[% ENV.env_or_default("PF_MYSQL_HOST", "localhost") %]
#
# database.port
#
# Port the MySQL server is running on.
port=[% ENV.env_or_default("PF_MYSQL_PORT", "3306") %]
#
# database.db
#
# Name of the MySQL database used by PacketFence.
db=[% ENV.env_or_default("PF_MYSQL_DB", "pf") %]
#
# database.user
#
# Username of the account with access to the MySQL database used by PacketFence. Changing this parameter after the initial configuration will *not* change it in the database it self, only in the configuration.
user=[% ENV.env_or_default("PF_MYSQL_USER", "pf") %]
#
# database.pass
#
# Password for the mysql database used by PacketFence. Changing this parameter after the initial configuration will *not* change it in the database it self, only in the configuration.
pass=[% ENV.env_or_default("PF_MYSQL_PASS", "packet") %]
#
# database.unix_socket
#
# Path to the database UNIX socket
unix_socket=[% ENV.env_or_default("PF_MYSQL_UNIX_SOCKET", "/var/lib/mysql/mysql.sock") %]

[database_proxysql]
#
# database_proxysql.status
#
#
status=[% ENV.env_or_default("PF_DATABASE_PROXYSQL_STATUS", "disabled") %]
#
# database_proxysql.cacert
#
#
cacert=[% ENV.env_or_default("PF_DATABASE_PROXYSQL_CACERT", "") %]
#
# database_proxysql.backend
#
#
backend=[% ENV.env_or_default("PF_DATABASE_PROXYSQL_BACKEND", "") %]
#
# database_proxysql.scheduler
#
scheduler=[% ENV.env_or_default("PF_DATABASE_PROXYSQL_BACKEND", "default") %]

[database_advanced]
#
# database_advanced.key_buffer_size
#
# The key_buffer_size MySQL configuration attribute (in MB). Only change if you know what you are doing. Will only affect a locally running MySQL server.
key_buffer_size=100
#
# database_advanced.innodb_buffer_pool_size
#
# The innodb_buffer_pool_size MySQL configuration attribute (in MB). Only change if you know what you are doing. Will only affect a locally running MySQL server.
innodb_buffer_pool_size=500
#
# database_advanced.query_cache_size
#
# The query_cache_size MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
query_cache_size=0
#
# database_advanced.thread_concurrency
#
# The thread_concurrency MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
thread_concurrency=8
#
# database_advanced.max_connections
#
# The max_connections MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
max_connections=1000
#
# database_advanced.table_cache
#
# The table_cache MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
table_cache=300
#
# database_advanced.thread_cache_size
#
# The thread_cache_size MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
thread_cache_size=25
#
# database_advanced.max_allowed_packet
#
# The max_allowed_packet MySQL configuration attribute (in MB). Only change if you know what you are doing. Will only affect a locally running MySQL server.
max_allowed_packet=16
#
# database_advanced.performance_schema
#
# The performance_schema MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
performance_schema=OFF
#
# database_advanced.max_connect_errors
#
# The max_connect_errors MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
max_connect_errors=100
# database_advanced.net_read_timeout
#
# The net_read_timeout MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
net_read_timeout=360s
#
# database_advanced.net_write_timeout
#
# The net_write_timeout MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
net_write_timeout=360s
#
# database_advanced.masterslave
#
# The masterslave configuration to enable or disable the master/slave configuration.
masterslave=OFF
#
# database_advanced.other_members
#
# Comma delimited IPv4 address of other member mysql members - note that this is only to sync the database.
other_members=

[services]
# services.pfipset
#
# Should pfipset be managed by PacketFence?
pfipset=enabled
#
# services.pfpki
#
# Should pfpki be managed by PacketFence?
pfpki=enabled
#
# services.galera-autofix
#
# Should galera-autofix be managed by PacketFence?
galera-autofix=enabled
#
# services.pfdhcp
#
# Should pfdhcp be managed by PacketFence?
pfdhcp=enabled
#
# services.pfdhcp_binary
#
# Location of the pfdhcp binary.
pfdhcp_binary=/usr/local/pf/sbin/pfdhcp
#
# services.haproxy-admin
#
# Should haproxy-admin be started?
haproxy-admin=enabled
#
# services.haproxy-admin_binary
#
# Location of the haproxy-admin binary. Only necessary to change if you are not running the RPMed version.
haproxy-admin_binary=/usr/sbin/haproxy
#
# services.haproxy-portal
#
# Should haproxy-portal be started?
haproxy-portal=enabled
#
# services.haproxy-portal_binary
#
# Location of the haproxy-portal binary. Only necessary to change if you are not running the RPMed version.
haproxy-portal_binary=/usr/sbin/haproxy
#
# services.haproxy-db
#
# Should haproxy-db be started?
haproxy-db=enabled
#
# services.haproxy-db_binary
#
# Location of the haproxy-db binary. Only necessary to change if you are not running the RPMed version.
haproxy-db_binary=/usr/sbin/haproxy
#
# services.pffilter
#
# Should pffilter be managed by PacketFence?
pffilter=enabled
#
# services.pfsso
#
# Should pfsso be managed by PacketFence?
pfsso=enabled
#
# services.pfldapexplorer
#
# Should ldapexplorer be managed by PacketFence?
pfldapexplorer=enabled
#
# services.radiusd
#
# Should radiusd be managed by PacketFence?
radiusd=enabled
# 
# services.radiusd_binary
# 
# Location of the named binary. Only necessary to change if you are not running the RPMed version.
radiusd_binary=/usr/sbin/radiusd
#
# services.radiusd_acct
#
# Should freeradius handling accounting
radiusd_acct=disabled
#
# services.radiusd_auth
#
# Should freeradius handling authentication
radiusd_auth=enabled
#
# services.httpd_portal
#
# Should httpd.portal be started?
httpd_portal=enabled
#
# services.pfperl-api
#
# Should pfperl-api be started?
pfperl-api=enabled
#
# services.httpd_webservices
#
# Should httpd.webservices be started?
httpd_webservices=enabled
#
# services.httpd_dispatcher
#
# Should httpd.dispatcher be started?
httpd_dispatcher=enabled
#
# services.httpd_admin_dispatcher
#
# Should httpd.admin_dispatcher be started?
httpd_admin_dispatcher=enabled
#
# services.httpd_aaa
#
# Should httpd.aaa be started?
httpd_aaa=enabled
#
# services.httpd_binary
#
# Location of the apache binary. Only necessary to change if you are not running the RPMed version.
httpd_binary=/usr/sbin/httpd
#
# services.snmptrapd
#
# Should snmptrapd be managed by PacketFence?
snmptrapd=disabled
#
# services.snmptrapd_binary
#
# Location of the snmptrapd binary. Only necessary to change if you are not using the RPMed version.
snmptrapd_binary=/usr/sbin/snmptrapd
#
# services.pfqueue-backend
#
# Should pfqueue-backend be managed by PacketFence?
pfqueue-backend=enabled
#
# services.pfqueue
#
# Should pfqueue be managed by PacketFence?
pfqueue=enabled
#
# services.pfqueue-go
#
# Should pfqueue-go be managed by PacketFence?
pfqueue-go=enabled
#
# services.pfcron
#
# Should pfcron be managed by PacketFence?
pfcron=enabled
#
# services.pfdetect
#
# Should pfdetect be started?
pfdetect=enabled
#
# services.redis_cache
#
# Should redis be managed by PacketFence?
redis_cache=enabled
# services.redis_queue
#
# Should redis be managed by PacketFence?
redis_queue=enabled
# services.redis_ntlm_cache
#
# Should redis be managed by PacketFence?
redis_ntlm_cache=disabled
# 
# services.redis_binary
# 
# Location of the redis binary. Only necessary to change if you are not running the pre-packaged version.
redis_binary=/usr/bin/redis-server
#
# services.pfdhcplistener
#
# Should pfdhcplistener be started?
pfdhcplistener=enabled
#
# services.pfdhcplistener_packet_size
#
# Set the max size of DHCP packets
# Do not change unless you know what you are doing
pfdhcplistener_packet_size=576
#
# services.keepalived
#
# Should keepalived be started?
keepalived=enabled
#
# services.keepalived_binary
#
# Location of the keepalived binary. Only necessary to change if you are not running the RPMed version.
keepalived_binary=/usr/sbin/keepalived
#
# services.radsniff
#
# Should radsniff be started?
radsniff=enabled
# 
# services.radsniff_binary
# 
# Location of the radsniff binary. Only necessary to change if you are not running the pre-packaged version.
radsniff_binary=/usr/bin/radsniff
#
# services.fingerbank-collector
#
# Should the fingerbank-collector be started?
fingerbank-collector=enabled
# 
# services.fingerbank-collector_binary
# 
# Location of the fingerbank-collector binary. Only necessary to change if you are not running the pre-packaged version.
fingerbank-collector_binary=/usr/local/fingerbank/collector/fingerbank-collector
#
# services.openssl_binary
#
# Location of the openssl binary. Only necessary to change if you are not running the RPMed version.
openssl_binary=/usr/bin/openssl
# 
# services.arp_binary
# 
# location of the arp binary. only necessary to change if you are not running the rpmed version.
arp_binary=/sbin/arp
#
# services.netdata
#
# Should netdata be managed by PacketFence?
netdata=enabled
#
# services.netdata_binary
#
# Location of the netdata binary. Only necessary to change if you are not running the RPMed version.
netdata_binary=/usr/sbin/netdata
#
# services.pfdns
#
# Should pfdns be managed by PacketFence?
pfdns=enabled
#
# services.pfdns_binary
#
# Location of the pfdns binary.
pfdns_binary=/usr/local/pf/sbin/pfdns

# services.pfacct
#
# Should pfacct be managed by PacketFence?
pfacct=enabled
#
# services.pfacct_binary
#
# Location of the pfacct binary.
pfacct_binary=/usr/local/pf/sbin/pfacct

#
# services.api-frontend
#
# Should routes be managed by PacketFence?
api-frontend=enabled

# services.pfstats
#
# Should pfstats be managed by PacketFence?
pfstats=enabled
#
# services.pfstats_binary
#
# Location of the pfstats binary.
pfstats_binary=/usr/local/pf/sbin/pfstats

# services.tracking-config
#
# Should tracking-config be managed by PacketFence?
tracking-config=enabled
#
# services.tracking-config_binary
#
# Location of the tracking-config binary.
tracking-config_binary=/dev/null

#
# services.netflow_address
#
# NetFlow Address
netflow_address=0.0.0.0

#
# services.netflow_target_host_port
#
# NetFlow Target Host Port
netflow_target_host_port=[% ENV.env_or_default("NETFLOW_TARGET_HOST_PORT", "containers-gateway.internal:2056") %]

#
# services.mysql-probe
#
# Should mysql-probe be managed by PacketFence?
mysql-probe=enabled

# services.pfconnector-client
#
# Should pfconnector-client be managed by PacketFence?
pfconnector-client=enabled

# services.pfconnector-server
#
# Should pfconnector-server be managed by PacketFence?
pfconnector-server=enabled
#
# services.proxysql
#
# Should proxysql be started?
proxysql=enabled
#
# services.proxysql_binary
#
# Location of the proxysql binary. Only necessary to change if you are not running the RPMed version.
proxysql_binary=/usr/bin/proxysql
#
# services.pfsetacls
#
# Should pfsetacls be started?
pfsetacls=enabled
#
# services.kafka
#
# Should Kafka be started?
kafka=disabled
#
# services.ntlm-auth-api
#
# Should ntlm-auth-api be started?
ntlm-auth-api=enabled
#
# services.firewalld
#
# Should firewalld be started?
firewalld=enabled

[snmp_traps]
#
# snmp_traps.bounce_duration
#
# Delay to wait between the shut / no-shut on a port. Some OS need a higher value than others.
# Default should be reasonable for almost every OS but is too long for the usual proprietary OS.
bounce_duration = 4s
#
# snmp_traps.trap_limit
#
# Controls whether or not the trap_limit feature is enabled. Trap limiting is
# a way to limit the damage done by malicious users or misbehaving switch 
# that sends too many traps to PacketFence causing it to be overloaded. Trap
# limiting is controlled by the trap_limit_threshold and trap_limit_action 
# parameters. Default is enabled.
trap_limit = enabled
#
# snmp_traps.trap_limit_threshold
#
# Maximum number of SNMP traps that a switchport can send to PacketFence within
# a minute without being flagged as DoS. Defaults to 100
trap_limit_threshold = 100
#
# snmp_traps.trap_limit_action
#
# Action that PacketFence will take if the snmp_traps.trap_limit_threshold is reached.
# Defaults to none. email will send an email every hour if the limit's still reached.
# shut will shut the port on the switch and will also send an email even if email is not
# specified.
trap_limit_action = 

[inline]
# inline.ports_redirect
#
# Ports to intercept and redirect for trapped and unregistered systems.  Defaults to 80/tcp (HTTP), 443/tcp (HTTPS).
# Redirecting 443/tcp (SSL) will work, although users might get certificate errors if you didn't install a valid 
# certificate or if you don't use DNS (although IP-based certificates supposedly exist)
# Redirecting 53/udp (DNS) seems to have issues and is also not recommended.
# We also have experimental IMAP and POP3 listeners which give fake emails telling users to open their browsers.
# Enable them via the ports.listeners parameter and add the IMAP (143/tcp) and POP3 (110/tcp) here.
ports_redirect=80/tcp,443/tcp
#
# inline.should_reauth_on_vlan_change
# Should have to reauthenticate the node if it change vlan
should_reauth_on_vlan_change = disabled
#
# inline.interfaceSNAT
# Choose the interface(s) you want to use to enable snat (by default it´s the management interface)
interfaceSNAT=

[captive_portal]
#
# captive_portal.ip_address
#
# The IP address the portal uses in the registration and isolation networks.
# This IP address should point to an IP outside the registration and isolation networks.
# Do not change unless you know what you are doing.
ip_address=66.70.255.147
#
# captive_portal.network_detection
#
# Enable or not the network detection feature after registration
network_detection=enabled
#
# captive_portal.network_detection_ip
#
# This IP is used as the webserver who hosts the common/network-access-detection.gif which is used to detect if network
# access was enabled. 
# It cannot be a domain name since it is used in registration or quarantine where DNS is blackholed.
# It is recommended that you allow your users to reach your packetfence server and put your LAN's PacketFence IP.
# By default we will make this reach PacketFence's website as an easy solution.
#
network_detection_ip = netdetect.packetfence.org
#
# captive_portal.network_detection_initial_delay
#
# This is the amount of time before network connectivity detection is started. 
network_detection_initial_delay = 5s
#
# captive_portal.network_detection_retry_delay
#
# This is the amount of time between network connectivity detection checks.
network_detection_retry_delay = 2s
#
# captive_portal.network_redirect_delay
#
# How long to display the progress bar during trap release. Default value is 
# based on VLAN enforcement techniques. Inline enforcement only users could
# lower the value.
network_redirect_delay = 90s
#
# captive_portal.image_path
#
# This is the path where the gif is on the webserver to detect if the network access
# has been enabled.
image_path = /common/network-access-detection.gif
#
# captive_portal.request_timeout
#
# The amount of seconds before a request times out in the captive portal
request_timeout = 15
#
# captive_portal.loadbalancers_ip
#
# If the captive portal is put behind load-balancer(s) that act at Layer 7 
# (HTTP level) effectively doing reverse proxying then the captive portal no 
# longer sees the IP of the node trying to access the portal. In that case,
# the load-balancers must do SSL offloading and add a X-Forwarded-By header
# in the HTTP traffic they forward to PacketFence. Most do by default. Then
# in this parameter you must specify the IP of the various load balancers.
# This will instruct the captive portal to look for client IPs in the 
# X-Forwarded-For instead of the actual TCP session when it matches an IP
# in the list. Format is a comma separated list of IPs. Note: Apache access
# log format is not changed to automatically log the X-Forwarded-By header.
# Modify conf/httpd.conf.d/captive-portal-common.conf to use 
# loadbalanced_combined instead of combined in CustomLog statement.
loadbalancers_ip=
#
# captive_portal.secure_redirect
#
# If secure_redirect is enabled, the captive portal uses HTTPS when redirecting
# captured clients. This is the default behavior.
secure_redirect=enabled
#
# captive_portal.status_only_on_production
#
# If status_only_on_production is enabled, the /status page will only be available on the
# production network. This is disabled by default
status_only_on_production=disabled
#
# captive_portal.detection_mecanism_bypass
#
# Bypass the captive-portal detection mechanism of some browsers / end-points by proxying the detection request.
detection_mecanism_bypass = disabled
#
# captive_portal.detection_mecanism_urls
#
# Comma-delimited list of URLs known to be used by devices to detect the presence 
# of a captive portal and trigger their captive portal mechanism.
detection_mecanism_urls = http://www.gstatic.com/generate_204,http://clients3.google.com/generate_204,http://www.apple.com/library/test/success,http://connectivitycheck.android.com/generate_204,http://connectivitycheck.gstatic.com/generate_204,http://www.msftncsi.com/ncsi.txt,http://www.appleiphonecell.com,http://captive.apple.com,http://captive.roku.com/ok,http://detectportal.firefox.com/success.txt,http://www.msftconnecttest.com/connecttest.txt,http://fireoscaptiveportal.com/generate_204,http://connectivitycheck.cbg-app.huawei.com/generate_204,http://connect.rom.miui.com/generate_204,http://freetimecaptiveportal.com/generate_204,http://gateway.zscalerthree.net/generate_204,http://gateway.zscloud.net/generate_204,http://g.cn/generate_204,http://play.googleapis.com/generate_204,http://speedtest-global.spatialbuzz.net/generate_204,http://tabletcaptiveportal.com/generate204,http://www.google.cn/generate_204,http://edge.microsoft.com/captiveportal/generate_204
#
# captive_portal.wispr_redirection
#
# Enable or disable WISPr redirection capabilities on the captive-portal
wispr_redirection = disabled
#
# captive_portal.rate_limiting
#
# Temporarily deny access to a user that performs too many requests on the captive portal on invalid URLs
rate_limiting = enabled
#
# captive_portal.rate_limiting_threshold
#
# Amount of requests on invalid URLs after which the rate limiting will kick in for this device
rate_limiting_threshold = 48
#
# captive_portal.other_domain_names
#
# Other domain names under which the captive portal responds
other_domain_names=
#
# captive_portal.expose_fingerbank_info_all_templates
#
# Expose the fingerbank_info to all the captive portal templates. Increases the response time of the portal due to it being slightly expensive to compute.
expose_fingerbank_info_all_templates = disabled

[advanced]
#
# advanced.api_inactivity_timeout
#
# The inactivity timeout of an API token
# Requires to restart the api-frontend service to be fully effective.
api_inactivity_timeout=15m
#
# advanced.api_max_expiration
#
# The maximum amount of time an API token can be valid
# Requires to restart the api-frontend service to be fully effective.
api_max_expiration=12h
#
# advanced.language
#
# Language choice for the communication with administrators
language=en_US
#
# advanced.admin_csp_security_headers
#
# Enforce Content-Security-Policy (CSP) HTTP response header in the admin interface
#
admin_csp_security_headers=disabled
#
# advanced.portal_csp_security_headers
#
# Enforce Content-Security-Policy (CSP) HTTP response header in the captive portal interface
#
portal_csp_security_headers=enabled
#
# advanced.scan_on_accounting
#
# Trigger scan engines on accounting
scan_on_accounting=disabled
#
# advanced.hash_passwords
#
# The algorithm to use to hash the passwords in the local database.
hash_passwords=bcrypt
#
# advanced.hashing_cost
#
# The cost factor to apply to the password hashing if applicable.
# Currently only applies to bcrypt.
hashing_cost=8
#
# advanced.disable_pf_domain_auth
#
# Disable Active-Directory domain configuration from within PacketFence
disable_pf_domain_auth=disabled
#
# advanced.ldap_attributes
#
# List of LDAP attributes that can be used in the sources configuration
ldap_attributes=uid,cn,sAMAccountName,servicePrincipalName,UserPrincipalName,department,displayName,distinguishedName,givenName,memberOf,sn,eduPersonPrimaryAffiliation,mail,postOfficeBox,description,groupMembership,basedn,dNSHostName
#
# advanced.pffilter_processes
#
# Amount of pffilter processes to start
pffilter_processes=4
#
# advanced.pfperl_api_processes
#
# Amount of pfperl-api processes to start
pfperl_api_processes=8
#
# advanced.update_iplog_with_accounting
#
# Use the information included in the accounting to update the iplog
update_iplog_with_accounting=disabled
#
# advanced.update_iplog_with_external_portal_requests
#
# Use the information included in the accounting to update the iplog
update_iplog_with_external_portal_requests=enabled
#
# advanced.locationlog_close_on_accounting_stop
#
# Close the locationlog for a node on accounting stop
locationlog_close_on_accounting_stop=enabled
#
# advanced.timing_stats_level
#
# Level of timing stats to keep - 0 is the lowest - 10 the highest amount to log
# Do not change unless you know what you are doing
timing_stats_level=5
#
# advanced.source_to_send_sms_when_creating_users
#
# The source to use to send an SMS when creating a user
source_to_send_sms_when_creating_users=
#
# advanced.multihost
#
# Ability to manage all active devices from a same switch port
multihost=disabled
#
# active_directory_os_join_check_bypass
#
# Enable to bypass the operating system domain join verification.
active_directory_os_join_check_bypass=disabled
# advanced.statsd_listen_port
#
# The port where statsd listen
statsd_listen_port = [% ENV.env_or_default("STATSD_LISTEN_PORT", "8125") %]
statsd_listen_host = [% ENV.env_or_default("STATSD_LISTEN_HOST", "127.0.0.1") %]

# advanced.pfperl_api_timeout
#
# Execution timeout for pfperl-api
pfperl_api_timeout = 600

# advanced.configurator
#
# Enable the Configurator and the Configurator API
configurator = enabled

# advanced.netflow_on_all_networks
#
# Listen to netflow on all networks
netflow_on_all_networks = disabled

# advanced.accounting_timebucket_size
#
# Accounting timebucket size
accounting_timebucket_size = 5m

# advanced.openid_attributes
#
# List of known OpenID Attributes
openid_attributes=email

# advanced.zero_trust_network_starting_ip
#
# The starting IP address of the Zero Trust network. Only change if you know what you are doing. Changing this value requires to restart all the PacketFence services and requires all the clients of the Zero Trust network to be restarted
zero_trust_network_starting_ip=100.64.0.1

# advanced.zero_trust_network_netmask
#
# The netmask (in numerical bits value) of the Zero Trust network. Only change if you know what you are doing. Changing this value requires to restart all the PacketFence services and requires all the clients of the Zero Trust network to be restarted
zero_trust_network_netmask=10

# advanced.pfupdate_custom_script_path
#
# Path to a custom script called by pfupdate
pfupdate_custom_script_path=/usr/local/bin/pfupdate-packetfence.sh

[provisioning]
#
# provisioning.autoconfig
#
# Enable or disable the XML mobile config generation for wireless on iPhones, iPods, and iPads
autoconfig = disabled

#
# provisioning.ssid
#
# SSID name where the users need to connect to upon registration
ssid = SSID-Hidden

#
# provisioning.category
#
# Accessible to node that are member of this category
category = any

#
# provisioning.certificate
#
# Certificate to send to the node
certificate = 

[node_import]
#
# node_import.pid
#
# Default pid value to assign to imported nodes.
pid=default
#
# node_import.category
#
# Default category to assign to imported nodes.
category=default
#
# node_import.voip
#
# By default is an imported node a Voice over IP device or not?
voip=no

[webservices]
#
# webservices.user
#
# username to use to connect to the webAPI
user=[% ENV.env_or_default("PF_WEBSERVICES_USER", "") %]
#
# webservices.pass
#
# password of the username
pass=[% ENV.env_or_default("PF_WEBSERVICES_PASS", "") %]
#
# webservices.host
#
# host of the webAPI
host=[% ENV.env_or_default("PF_WEBSERVICES_HOST", "containers-gateway.internal") %]
#
# webservices.proto
#
# proto to use
proto=[% ENV.env_or_default("PF_WEBSERVICES_PROTO", "https") %]
#
# webservices.port
#
# port to use
port=[% ENV.env_or_default("PF_WEBSERVICES_PORT", "9090") %]
#
# webservices.aaa_host
#
# host to use for authentication
aaa_host=[% ENV.env_or_default("PF_WEBSERVICES_AAA_HOST", "containers-gateway.internal") %]
#
# webservices.aaa_port
#
# port to use for authentication
aaa_port=[% ENV.env_or_default("PF_WEBSERVICES_AAA_PORT", "7070") %]
#
# webservices.aaa_port
#
# port to use for authentication
aaa_proto=[% ENV.env_or_default("PF_WEBSERVICES_AAA_PROTO", "http") %]
#
# webservices.unifiedapi_host
#
# host to use for accessing the Unified API
unifiedapi_host=[% ENV.env_or_default("PF_WEBSERVICES_UNIFIEDAPI_HOST", "containers-gateway.internal") %]
#
# webservices.unifiedapi_port
#
# port to use for accessing the Unified API
unifiedapi_port=[% ENV.env_or_default("PF_WEBSERVICES_UNIFIEDAPI_PORT", "9999") %]

[active_active]
#
# active_active.password
#
# Shared KEY for vrrp protocol (Must be the same on all members).
password=1234
#
# active_active.virtual_router_id
#
# Shared KEY for vrrp protocol (Must be the same on all members).
virtual_router_id=50
#
# active_active.vrrp_unicast
#
# Enable keepalived in unicast mode instead of multicast
vrrp_unicast=disabled
#
# active_active.dns_on_vip_only
#
# Set the name server option in DHCP replies to point only to the VIP in cluster mode rather than to all servers in the cluster.
dns_on_vip_only=disabled
#
# active_active.gateway_on_vip_only
# Set the gateway option in DHCP replies to point only to the VIP in cluster mode rather than to all servers in the cluster.
gateway_on_vip_only=disabled
#
# active_active.centralized_deauth
#
# Centralize the deauthentication to the management node of the cluster.
centralized_deauth=enabled
#
# active_active.use_vip_for_deauth
#
# Use the virtual IP as the source IP during deauthentication
use_vip_for_deauth=enabled
#
# active_active.portal_on_management
#
# Process captive portal requests on the management server (the current load balancer).
# Disabling it will make the management server only proxy requests to other servers.
# Useful if your load balancer cannot handle both tasks.
# Changing this requires to restart the haproxy-portal service.
portal_on_management=enabled
#
# active_active.auth_on_management
#
# Process RADIUS authentication requests on the management server (the current load balancer).
# Disabling it will make the management server only proxy requests to other servers.
# Useful if your load balancer cannot handle both tasks.
# Changing this requires to restart radiusd.
auth_on_management=enabled
#
# active_active.conflict_resolution_threshold
#
# Defines the amount of seconds after which pfcron attempts to resolve a configuration version conflict between cluster members.
# For example, if this is set to 5 minutes, then a resolution will be attempted when the members will be detected running a different version for more than 5 minutes.
conflict_resolution_threshold=5m
#
# active_active.galera_replication
#
# Whether or not to activate galera cluster when using a cluster
galera_replication=enabled
#
# active_active.galera_replication_username
#
# Defines the replication username to be used for the MariaDB Galera cluster replication
galera_replication_username=
#
# active_active.galera_replication_password
#
# Defines the replication password to be used for the MariaDB Galera cluster replication
galera_replication_password=
#
# active_active.centralize_vips
#
# Centralize the virtual IP addresses on the same node instead of distributing them on the two first nodes of the cluster
centralize_vips=disabled
#
# active_active.probe_mysql_from_haproxy_db
#
# Enable mysql-probe in haproxy-db to detect the availability of the MariaDB servers.
probe_mysql_from_haproxy_db=disabled
#
# active_active.radius_proxy_with_vip
#
# Proxy the RADIUS requests received on the RADIUS load balancer using the VIP
# When deploying in an environment where the virtual IP is a software load balancer, disable this so that servers proxy the requests using their own IP address
radius_proxy_with_vip=enabled
#
# active_active.firewall_sso_on_management
#
# Process Firewall SSO only on the managemenr server (the current load balancer).
# Disabling it will allow each members of the cluster to send Firewall SSO request to firewalls
firewall_sso_on_management=disabled

[parking]
#
# parking.lease_length
#
# Lease length (in seconds) when a device is in parking
lease_length=3600
#
# parking.lease_length
#
# The threshold (in seconds) after which a device will be placed in parking
# A value of 0 deactivates the parking detection.
# The detection works by looking at the time in seconds a device has been in the registration role and comparing it with this threshold
threshold=0
#
# parking.place_in_dhcp_parking_group
#
# Place the device in the DHCP parking group when it is detected doing parking
place_in_dhcp_parking_group=enabled
#
# parking.show_parking_portal
#
# Show the parking portal to the device instead of the usual portal
show_parking_portal=enabled

[mse_tab]
#
# mse_tab.enabled
#
# Enabled MSE tab
enabled=disabled
#
# mse_tab.url
#
# URL of MSE server
url=
#
# mse_tab.user
#
# Username of MSE server
user=
#
# mse_tab.pass
#
# Password of MSE server
pass=

[radius_configuration]
#
# radius_configuration.record_accounting_in_sql
#
# Record the accounting data in the SQL tables.
# Requires a restart of radiusd to be effective.
record_accounting_in_sql=enabled
#
# advanced.filter_in_packetfence_authorize
#
# Send the radius request in the radius filter from the radius packetfence.authorize section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_authorize=disabled
#
# radius_configuration.filter_in_packetfence_pre_proxy
#
# Send the radius request in the radius filter from the radius packetfence.pre_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_pre_proxy=disabled
#
# radius_configuration.filter_in_packetfence_post_proxy
#
# Send the radius request in the radius filter from the radius packetfence.post_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_post_proxy=disabled
#
# radius_configuration.filter_in_packetfence_preacct
#
# Send the radius request in the radius filter from the radius packetfence.preacct section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_preacct=disabled
#
# radius_configuration.filter_in_packetfence_accounting
#
# Send the radius request in the radius filter from the radius packetfence.accounting section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_accounting=disabled
#
# radius_configuration.filter_in_packetfence-tunnel_authorize
#
# Send the radius request in the radius filter from the radius packetfence-tunnel.authorize section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence-tunnel_authorize=disabled
#
# advanced.filter_in_eduroam_authorize
#
# Send the radius request in the radius filter from the radius eduroam.authorize section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_authorize=disabled
#
# radius_configuration.filter_in_eduroam_pre_proxy
#
# Send the radius request in the radius filter from the radius eduroam.pre_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_pre_proxy=disabled
#
# radius_configuration.filter_in_eduroam_post_proxy
#
# Send the radius request in the radius filter from the radius eduroam.post_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_post_proxy=disabled
#
# radius_configuration.filter_in_eduroam_preacct
#
# Send the radius request in the radius filter from the radius eduroam.preacct section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_preacct=disabled
#
# radius_configuration.ntlm_redis_cache
#
# Enables a Redis driven cache for NTLM authentication. 
# In order for this to work, you need to setup proper NT hash syncronization between your PacketFence server and your AD.
# Refer to the Administration guide for more details.
# Applying this requires a restart of radiusd.
ntlm_redis_cache=disabled
#
# radius_configuration.radius_attributes
#
# List of RADIUS attributes that can be used in the sources configuration
radius_attributes=Packetfence-Raw,User-Name,username,NAS-Identifier,Called-Station-Id,Calling-Station-Id
#
# radius_configuration.normalize_radius_machine_auth_username
#
# Normalize the radius machine auth username
normalize_radius_machine_auth_username=disabled
#
# radius_configuration.username_attributes
#
# Which attributes to use to get the username from a RADIUS request
# The order of the attributes are listed in this configuration parameter is followed while performing the lookup
username_attributes=PacketFence-UserNameAttribute,TLS-Client-Cert-Subject-Alt-Name-Upn,TLS-Client-Cert-Subject-Alt-Name-Dns,TLS-Client-Cert-Common-Name,User-Name
# radius_configuration.forward_key_balanced
#
# Send in the proxy request the attribute PacketFence-KeyBalanced to randomize the load balance in the next PacketFence RADIUS server
forward_key_balanced=disabled
# radius_configuration.local_auth
local_auth=disabled
# radius_configuration.process_bandwidth_accounting
#
# Process bandwidth accounting.
process_bandwidth_accounting = disabled
# radius_configuration.pfacct_workers
#
# The number of workers proccessing accounting packets.
pfacct_workers = 5
# radius_configuration.pfacct_work_queue_size
#
# The size of the queue for each worker.
pfacct_work_queue_size = 1000

[dns_configuration]
#
# dns_configuration.record_dns_in_sql
#
# Record dns requests and replies in SQL table
record_dns_in_sql=disabled

[pfdhcp]
#
# pfdhcp.ip2mac_lookup
#
# Use the Unified API to query pfdhcp for the MAC address of a given IP address
ip2mac_lookup=disabled
#
# pfdhcp.mac2ip_lookup
#
# Use the Unified API to query pfdhcp for the IP address of a given MAC address
mac2ip_lookup=disabled
#
# pfdhcp.connect_timeout_ms
#
# Timeout (in milliseconds) to connect to the Unified API when performing queries
connect_timeout_ms=200
#
# pfdhcp.timeout_ms
#
# Timeout (in milliseconds) when performing queries to the Unified API
timeout_ms=200

[fingerbank_device_change]
# 
# fingerbank_device_change.enable
#
# Whether or not the Fingerbank device change feature is enabled
enable=disabled

#
# fingerbank_device_change.trigger_on_device_class_change
#
# Whether or not internal::fingerbank_device_change should be triggered when we detect a device class change in Fingerbank
trigger_on_device_class_change=enabled

#
# fingerbank_device_change.device_class_whitelist
# 
# Which device class changes are allowed in conjunction with trigger_on_device_class_change
# Comma delimited transitions using the following format: $PREVIOUS_DEVICE_CLASS_ID->$NEW_DEVICE_CLASS_ID where $PREVIOUS_DEVICE_CLASS_ID and $NEW_DEVICE_CLASS_ID are the IDs in the Fingerbank database.
device_class_whitelist=

#
# fingerbank_device_change.triggers
#
# Which changes (changing from a device class to another) should trigger internal::fingerbank_device_change
# This setting is independant from trigger_on_device_class_change and allows to specify exactly which transitions should trigger internal::fingerbank_device_change
# Comma delimited transitions using the following format: $PREVIOUS_DEVICE_CLASS_ID->$NEW_DEVICE_CLASS_ID where $PREVIOUS_DEVICE_CLASS_ID and $NEW_DEVICE_CLASS_ID are the IDs in the Fingerbank database.
triggers=

[pfconnector]
redis_server=[% ENV.env_or_default("REDIS_CACHE_HOST_PORT", "containers-gateway.internal:6379") %]
redis_tunnels_namespace=pfconnector:activeTunnels:

[lets_encrypt]
#
# lets_encrypt.radius
# Whether or not Let's Encrypt should be enabled for RADIUS certificate management
radius=disabled
#
# lets_encrypt.http
# Whether or not Let's Encrypt should be enabled for HTTP certificate management
http=disabled
#
# lets_encrypt.live
# Whether or not Let's Encrypt should be using the live ACME API. Set to disabled only for testing since the certificates that will be issued will not be valid.
live=enabled
#
# lets_encrypt.test_uri
# The URI to use to test that the portal is available publicly
test_uri=https://ssl-test.inverse.ca/

[monit]
status=disabled
alert_email_to=
subject_prefix=
configurations=packetfence,os-checks
mailserver=
sender=monit@$HOST

[services_url]
httpd_portal=[% ENV.env_or_default("PF_SERVICES_URL_HTTPD_PORTAL", "http://containers-gateway.internal:8080") %]
httpd_dispatcher=[% ENV.env_or_default("PF_SERVICES_URL_HTTPD_DISPATCHER", "http://containers-gateway.internal:8888") %]
httpd_dispatcher_static=[% ENV.env_or_default("PF_SERVICES_URL_HTTPD_DISPATCHER_STATIC", "http://containers-gateway.internal:8889") %]
httpd_admin_dispatcher_static=[% ENV.env_or_default("PF_SERVICES_URL_HTTPD_ADMIN_DISPATCHER_STATIC", "http://containers-gateway.internal:8891") %]
pfpki=[% ENV.env_or_default("PF_SERVICES_URL_PFPKI", "http://containers-gateway.internal:22225") %]
pfipset=[% ENV.env_or_default("PF_SERVICES_URL_PFIPSET", "http://containers-gateway.internal:22223") %]
pfdhcp=[% ENV.env_or_default("PF_SERVICES_URL_PFDHCP", "http://containers-gateway.internal:22222") %]
pfperl-api=[% ENV.env_or_default("PF_SERVICES_URL_PFPERL_API", "http://containers-gateway.internal:22224") %]
pfdns-doh=[% ENV.env_or_default("PF_SERVICES_URL_PFDNS_DOH", "http://containers-gateway.internal:853") %]
pfsso=[% ENV.env_or_default("PF_SERVICES_URL_PFSSO", "http://containers-gateway.internal:8777") %]
pfldapexplorer=[% ENV.env_or_default("PF_SERVICES_URL_PFLDAPEXPLORER", "http://containers-gateway.internal:22229") %]
pfconnector-server=[% ENV.env_or_default("PF_SERVICES_URL_PFCONNECTOR_SERVER", "http://containers-gateway.internal:22226") %]
api-frontend=[% ENV.env_or_default("PF_SERVICES_URL_API_FRONTEND", "https://containers-gateway.internal:9999") %]
netdata=[% ENV.env_or_default("PF_SERVICES_URL_NETDATA", "http://containers-gateway.internal:19999") %]

[admin_login]
sso_status=disabled
sso_base_url=
sso_login_path=/admin-sso
sso_authorize_path=/portaltoken
sso_login_text=Single Sign On
allow_username_password=enabled

[fleetdm]
host=
email=
password=
token=
