# Copyright (C) Inverse inc.
[general]
#
# general.domain
#
# Domain name of PacketFence system.
domain=packetfence.org
#
# general.hostname
#
# Hostname of PacketFence system.  This is concatenated with the domain in Apache rewriting rules and therefore must be resolvable by clients.
hostname=packetfence
#
# general.dhcpservers
#
# Comma-delimited list of DHCP servers.  Passthroughs are created to allow DHCP transactions from even "trapped" nodes.
dhcpservers=127.0.0.1
#
# general.timezone
#
# System's timezone in string format. List generated from Perl library DateTime::TimeZone
# When left empty, it will use the timezone of the server
timezone=

[network]
#
# network.dhcpdetector
#
# If enabled, PacketFence will monitor DHCP-specific items such as rogue DHCP services, DHCP-based OS fingerprinting, computername/hostname 
# resolution, and (optionnally) option-82 location-based information.  The monitored DHCP packets are DHCPDISCOVERs and DHCPREQUESTs - both are broadcasts, 
# meaning a span port is not necessary.  This feature is highly recommended if the internal network is DHCP-based.
dhcpdetector=enabled
#
# network.dhcp_rate_limiting
#
# Will rate-limit DHCP packets that contain the same information.
# For example, a DHCPREQUEST for the same MAC/IP will only be processed once in the timeframe configured below.
# This is independant of the DHCP server/relay handling the packet and is only based on the IP, MAC Address and DHCP type inside the packet.
# A value of 0 will disable the rate limitation.
dhcp_rate_limiting=5s
#
# network.rogue_dhcp_detection
#
# Tries to identify Rogue DHCP Servers and triggers the 1100010 security_event if one is found.
# This feature is only available if the dhcpdetector is activated.
rogue_dhcp_detection=enabled
#
# network.rogueinterval
#
# When rogue DHCP server detection is enabled, this parameter defines how often to email administrators.  With its default 
# setting of 10, it will email administrators the details of the previous 10 DHCP offers.
rogueinterval=10
#
# network.hostname_change_detection
#
# Will identify hostname changes and send an e-mail with these changes.
# This can help detect MAC spoofing.
hostname_change_detection=disabled
#
# network.connection_type_change_detection
#
# Will identify if a device switches from wired to wireless (or the opposite) and send an e-mail with these changes.
# This can help detect MAC spoofing.
connection_type_change_detection=disabled
#
# network.dhcpoption82logger
#
# If enabled PacketFence will monitor DHCP option82 location-based information.
# This feature is only available if the dhcpdetector is activated.
dhcpoption82logger=disabled
#
# network.dhcp_filter_by_message_types
#
# Which dhcp message types are being listened by the pfdhcplistener.
# Do not change unless you know what you are doing
#Possibilities are: DHCPOFFER,DHCPREQUEST,DHCPDECLINE,DHCPACK,DHCPRELEASE
dhcp_filter_by_message_types=DHCPREQUEST,DHCPACK
#
# network.dhcp_process_ipv6
#
# Enable/disable ipv6 dhcp packets processing by pfdhcplistener.
dhcp_process_ipv6=enabled
#
# network.force_listener_update_on_ack
#
# This will only do the iplog update and other DHCP related task on a DHCPACK.
# You need to make sure the UDP reflector is in place so this works on the production network.
# This is implicitly activated on registration interfaces on which dhcpd runs.
force_listener_update_on_ack=disabled
#
# network.interfaceSNAT
# Choose interface(s) where you want to enable snat for passthrough (by default it's the management interface)
interfaceSNAT=

[fencing]
# 
# fencing.wait_for_redirect
#
# How many seconds should the WebAPI sleep before actually triggering the VLAN change.
# This is meant to give the device enough time to fetch the redirection page before 
# switching VLAN.
wait_for_redirect = 1
#
# fencing.whitelist
#
# Comma-delimited list of MAC addresses that are immune to isolation. In 
# inline level 2 enforcement, the firewall is opened for them as if they were 
# registered. This "feature" will probably be reworked in the future.
whitelist=
#
# fencing.range
#
# Comma-delimited list of address ranges/CIDR blocks that Snort/Suricata will monitor/detect/trap on.  Gateway, network, and 
# broadcast addresses are ignored.
range=
#
# fencing.passthrough
#
# When enabled, pfdns will resolve the real IP addresses of passthroughs and add them in the ipset session to give access
# to trapped devices. Don´t forget to enable ip_forward on your server.
passthrough=enabled
#
# fencing.passthroughs
#
# Comma-delimited list of domains to be used as HTTP and HTTPS passthroughs to web sites.
#
passthroughs=
#
# fencing.proxy_passthroughs
#
# Comma-delimited list of domains to be use for apache passthrough
proxy_passthroughs=crl.geotrust.com,ocsp.geotrust.com,crl.thawte.com,ocsp.thawte.com,crl.comodoca.com,ocsp.comodoca.com,crl.incommon.org,ocsp.incommon.org,crl.usertrust.com,ocsp.usertrust.com,mscrl.microsoft.com,crl.microsoft.com,ocsp.apple.com,ocsp.digicert.com,ocsp.entrust.com,srvintl-crl.verisign.com,ocsp.verisign.com,ctldl.windowsupdate.com,crl.globalsign.net,pki.google.com,www.microsoft.com,crl.godaddy.com,ocsp.godaddy.com,certificates.godaddy.com,crl.globalsign.com,secure.globalsign.com,cacerts.digicert.com,crt.comodoca.com,crl.incommon-rsa.org,crl.quovadisglobal.com,cert.incommon.org,crt.usertrust.com,crl.verisign.com,crl.starfieldtech.com,developer.apple.com,ts-crl.ws.symantec.com,certificates.intel.com
#
# fencing.isolation_passthrough
#
# When enabled, pfdns will resolve the real IP addresses of passthroughs and add them in the ipset session to give access
# to trapped devices. Don´t forget to enable ip_forward on your server.
isolation_passthrough=disabled
#
# fencing.isolation_passthroughs
#
# Comma-delimited list of domains to be used as HTTP and HTTPS passthroughs to web sites.
#
isolation_passthroughs=
#
# fencing.interception_proxy
#
# When enabled, packetfence will intercept proxy request to somes specified port
interception_proxy=disabled
#
# fencing.interception_proxy_port
#
# Comma-delimited list of port used to intercept proxy traffic
interception_proxy_port=8080,3128

[guests_admin_registration]
#
# guests_admin_registration.access_duration_choices
#
# These are all the choices offered in the guest management interface as 
# possible access duration values for a given registration.
access_duration_choices=1h,3h,12h,1D,2D,3D,5D
#
# guests_admin_registration.default_access_duration
#
# This is the default access duration value selected in the dropdown on the 
# guest management interface.
default_access_duration=12h

[alerting]
#
# alerting.emailaddr
#
# Comma-delimited list of email addresses to which notifications of rogue DHCP servers, security_events with an action of "email", or any other
# PacketFence-related message goes to.
emailaddr=pf@localhost
#
# alerting.fromaddr
#
# Source email address for email notifications. Empty means root@<server-domain-name>.
fromaddr=
#
# alerting.smtpserver
#
# Server through which to send messages to the above emailaddr.  The default is localhost - be sure you're running an SMTP 
# host locally if you don't change it!
smtpserver=localhost
#
# alerting.subjectprefix
#
#Subject prefix for email notifications of rogue DHCP servers, security_events with an action of "email", or any other
#PacketFence-related message.
subjectprefix=PF Alert:
#
# alerting.smtp_encryption
#
# Encryption style when connecting to the SMTP server.
smtp_encryption=none
#
# alerting.smtp_port
#
# The port of the SMTP server.
# If the port is set to 0 then port is calculated by the encryption type.
# none:25, ssl:465, starttls:587
smtp_port=0
#
# alerting.smtp_username
#
# The username used to connect to the SMTP server
smtp_username=
#
# alerting.smtp_password
#
# The password used to connect to the SMTP server
smtp_password=
#
# alerting.smtp_verify_ssl
#
# Verify SSL connection
smtp_verifyssl=enabled
#
# alerting.smtp_timeout
#
# The timeout in seconds for sending an email
smtp_timeout=20

[ports]
#
# ports.admin
#
# Port the administrative interface listens on.
admin=1443
#
# ports.soap
#
# Port of the soap interface listens on.
soap=9090
#
# ports.collector
#
# Port of the collector interface listens on.
collector=9292
#
# ports.aaa
#
# Port of the aaa http interface listens on.
aaa=7070
#
# ports.httpd_portal_modstatus
#
# Port the mod_status for httpd.portal listens on.
httpd_portal_modstatus=1444
#
# ports.unified_api
#
# port to use for accessing the Unified API
unifiedapi=9999
#
# ports.pfacct_netflow
#
# port for listening to netflow
pfacct_netflow=2056

[database]
#
# database.host
#
# Server the MySQL server is running on.
host=localhost
#
# database.port
#
# Port the MySQL server is running on.
port=3306
#
# database.db
#
# Name of the MySQL database used by PacketFence.
db=pf
#
# database.user
#
# Username of the account with access to the MySQL database used by PacketFence. Changing this parameter after the initial configuration will *not* change it in the database it self, only in the configuration.
user=pf
#
# database.pass
#
# Password for the mysql database used by PacketFence. Changing this parameter after the initial configuration will *not* change it in the database it self, only in the configuration.
pass=packet

[database_advanced]
#
# database_advanced.key_buffer_size
#
# The key_buffer_size MySQL configuration attribute (in MB). Only change if you know what you are doing. Will only affect a locally running MySQL server.
key_buffer_size=100
#
# database_advanced.innodb_buffer_pool_size
#
# The innodb_buffer_pool_size MySQL configuration attribute (in MB). Only change if you know what you are doing. Will only affect a locally running MySQL server.
innodb_buffer_pool_size=500
#
# database_advanced.query_cache_size
#
# The query_cache_size MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
query_cache_size=0
#
# database_advanced.thread_concurrency
#
# The thread_concurrency MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
thread_concurrency=8
#
# database_advanced.max_connections
#
# The max_connections MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
max_connections=1000
#
# database_advanced.table_cache
#
# The table_cache MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
table_cache=300
#
# database_advanced.thread_cache_size
#
# The thread_cache_size MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
thread_cache_size=25
#
# database_advanced.max_allowed_packet
#
# The max_allowed_packet MySQL configuration attribute (in MB). Only change if you know what you are doing. Will only affect a locally running MySQL server.
max_allowed_packet=16
#
# database_advanced.performance_schema
#
# The performance_schema MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
performance_schema=OFF
#
# database_advanced.max_connect_errors
#
# The max_connect_errors MySQL configuration attribute. Only change if you know what you are doing. Will only affect a locally running MySQL server.
max_connect_errors=100
#
# database_advanced.masterslave
#
# The masterslave configuration to enable or disable the master/slave configuration.
masterslave=OFF
#
# database_advanced.other_members
#
# Comma delimited IPv4 address of other member mysql members - note that this is only to sync the database.
other_members=

[services]
# services.pfipset
#
# Should pfipset be managed by PacketFence?
pfipset=enabled
#
# services.pfpki
#
# Should pfpki be managed by PacketFence?
pfpki=enabled
#
# services.galera-autofix
#
# Should galera-autofix be managed by PacketFence?
galera-autofix=enabled
#
# services.pfdhcp
#
# Should pfdhcp be managed by PacketFence?
pfdhcp=enabled
#
# services.pfdhcp_binary
#
# Location of the pfdhcp binary.
pfdhcp_binary=/usr/local/pf/sbin/pfdhcp
#
# services.haproxy-admin
#
# Should haproxy-admin be started?
haproxy-admin=enabled
#
# services.haproxy-admin_binary
#
# Location of the haproxy-admin binary. Only necessary to change if you are not running the RPMed version.
haproxy-admin_binary=/usr/sbin/haproxy
#
# services.haproxy-portal
#
# Should haproxy-portal be started?
haproxy-portal=enabled
#
# services.haproxy-portal_binary
#
# Location of the haproxy-portal binary. Only necessary to change if you are not running the RPMed version.
haproxy-portal_binary=/usr/sbin/haproxy
#
# services.haproxy-db
#
# Should haproxy-db be started?
haproxy-db=enabled
#
# services.haproxy-db_binary
#
# Location of the haproxy-db binary. Only necessary to change if you are not running the RPMed version.
haproxy-db_binary=/usr/sbin/haproxy
#
# services.pffilter
#
# Should pffilter be managed by PacketFence?
pffilter=enabled
#
# services.pfsso
#
# Should pfsso be managed by PacketFence?
pfsso=enabled
#
# services.radiusd
#
# Should radiusd be managed by PacketFence?
radiusd=enabled
# 
# services.radiusd_binary
# 
# Location of the named binary. Only necessary to change if you are not running the RPMed version.
radiusd_binary=/usr/sbin/radiusd
#
# services.radiusd_acct
#
# Should freeradius handling accounting
radiusd_acct=disabled
#
# services.radiusd_auth
#
# Should freeradius handling authentication
radiusd_auth=enabled
#
# services.iptables
#
# Should iptables be managed by PacketFence?
iptables=enabled
# 
# services.iptables_binary
# 
# location of the iptables binary. only necessary to change if you are not running the rpmed version.
iptables_binary=/sbin/iptables
#
# services.httpd_admin
#
# Should httpd.admin be started?
httpd_admin=disabled
#
# services.httpd_portal
#
# Should httpd.portal be started?
httpd_portal=enabled
#
# services.pfperl-api
#
# Should pfperl-api be started?
pfperl-api=enabled
#
# services.httpd_webservices
#
# Should httpd.webservices be started?
httpd_webservices=enabled
#
# services.httpd_collector
#
# Should httpd.collector be started?
httpd_collector=disabled
#
# services.httpd_dispatcher
#
# Should httpd.dispatcher be started?
httpd_dispatcher=enabled
#
# services.httpd_admin_dispatcher
#
# Should httpd.admin_dispatcher be started?
httpd_admin_dispatcher=enabled
#
# services.httpd_aaa
#
# Should httpd.aaa be started?
httpd_aaa=enabled
#
# services.httpd_proxy
#
# Should httpd.proxy be started?
httpd_proxy=enabled
#
# services.httpd_binary
#
# Location of the apache binary. Only necessary to change if you are not running the RPMed version.
httpd_binary=/usr/sbin/httpd
#
# services.snmptrapd
#
# Should snmptrapd be managed by PacketFence?
snmptrapd=disabled
#
# services.snmptrapd_binary
#
# Location of the snmptrapd binary. Only necessary to change if you are not using the RPMed version.
snmptrapd_binary=/usr/sbin/snmptrapd
#
# services.pfqueue
#
# Should pfqueue be managed by PacketFence?
pfqueue=enabled
#
# services.pfmon
#
# Should pfmon be managed by PacketFence?
pfmon=enabled
#
# services.redis_cache
#
# Should redis be managed by PacketFence?
redis_cache=enabled
# services.redis_queue
#
# Should redis be managed by PacketFence?
redis_queue=enabled
# services.redis_ntlm_cache
#
# Should redis be managed by PacketFence?
redis_ntlm_cache=disabled
# 
# services.redis_binary
# 
# Location of the redis binary. Only necessary to change if you are not running the pre-packaged version.
redis_binary=/usr/bin/redis-server
#
# services.pfdhcplistener
#
# Should pfdhcplistener be started?
pfdhcplistener=enabled
#
# services.pfdhcplistener_packet_size
#
# Set the max size of DHCP packets
# Do not change unless you know what you are doing
pfdhcplistener_packet_size=576
#
# services.keepalived
#
# Should keepalived be started?
keepalived=enabled
#
# services.keepalived_binary
#
# Location of the keepalived binary. Only necessary to change if you are not running the RPMed version.
keepalived_binary=/usr/sbin/keepalived
# services.winbindd
#
# Should winbindd be started?
winbindd=enabled
# 
# services.winbindd_binary
# 
# location of the winbindd binary. only necessary to change if you are not running the rpmed version.
winbindd_binary=/usr/sbin/winbindd
#
# services.radsniff
#
# Should radsniff be started?
radsniff=enabled
# 
# services.radsniff_binary
# 
# Location of the radsniff binary. Only necessary to change if you are not running the pre-packaged version.
radsniff_binary=/usr/bin/radsniff
#
# services.fingerbank-collector
#
# Should the fingerbank-collector be started?
fingerbank-collector=enabled
# 
# services.fingerbank-collector_binary
# 
# Location of the fingerbank-collector binary. Only necessary to change if you are not running the pre-packaged version.
fingerbank-collector_binary=/usr/local/fingerbank/collector/fingerbank-collector
#
# services.openssl_binary
#
# Location of the openssl binary. Only necessary to change if you are not running the RPMed version.
openssl_binary=/usr/bin/openssl
# 
# services.arp_binary
# 
# location of the arp binary. only necessary to change if you are not running the rpmed version.
arp_binary=/sbin/arp
#
# services.netdata
#
# Should netdata be managed by PacketFence?
netdata=enabled
#
# services.netdata_binary
#
# Location of the netdata binary. Only necessary to change if you are not running the RPMed version.
netdata_binary=/usr/sbin/netdata
# services.tc
#
# Should tc be managed by PacketFence?
tc=enabled
#
# services.tc_binary
#
# location of the yc binary. only necessary to change if you are not running the rpmed version.
tc_binary=/usr/sbin/tc
# services.pfdns
#
# Should pfdns be managed by PacketFence?
pfdns=enabled
#
# services.pfdns_binary
#
# Location of the pfdns binary.
pfdns_binary=/usr/local/pf/sbin/pfdns

# services.pfacct
#
# Should pfacct be managed by PacketFence?
pfacct=enabled
#
# services.pfacct_binary
#
# Location of the pfacct binary.
pfacct_binary=/usr/local/pf/sbin/pfacct

# services.pfcertmanager
#
# Should pfcertmanager be managed by PacketFence?
pfcertmanager=enabled
#
# services.pfcertmanager_binary
#
# Location of the pfcertmanager binary.
pfcertmanager_binary=/usr/local/pf/sbin/pfcertmanager

#
# services.api-frontend
#
# Should routes be managed by PacketFence?
api-frontend=enabled

# services.pfstats
#
# Should pfstats be managed by PacketFence?
pfstats=enabled
#
# services.pfstats_binary
#
# Location of the pfstats binary.
pfstats_binary=/usr/local/pf/sbin/pfstats

# services.tracking-config
#
# Should tracking-config be managed by PacketFence?
tracking-config=enabled
#
# services.tracking-config_binary
#
# Location of the tracking-config binary.
tracking-config_binary=/dev/null

[snmp_traps]
#
# snmp_traps.bounce_duration
#
# Delay to wait between the shut / no-shut on a port. Some OS need a higher value than others.
# Default should be reasonable for almost every OS but is too long for the usual proprietary OS.
bounce_duration = 4s
#
# snmp_traps.trap_limit
#
# Controls whether or not the trap_limit feature is enabled. Trap limiting is
# a way to limit the damage done by malicious users or misbehaving switch 
# that sends too many traps to PacketFence causing it to be overloaded. Trap
# limiting is controlled by the trap_limit_threshold and trap_limit_action 
# parameters. Default is enabled.
trap_limit = enabled
#
# snmp_traps.trap_limit_threshold
#
# Maximum number of SNMP traps that a switchport can send to PacketFence within
# a minute without being flagged as DoS. Defaults to 100
trap_limit_threshold = 100
#
# snmp_traps.trap_limit_action
#
# Action that PacketFence will take if the snmp_traps.trap_limit_threshold is reached.
# Defaults to none. email will send an email every hour if the limit's still reached.
# shut will shut the port on the switch and will also send an email even if email is not
# specified.
trap_limit_action = 

[inline]
# inline.accounting
#
# Should we handle accouting data for inline clients?
# This controls inline accouting tasks in pfmon.
accounting = disabled
#
# inline.layer3_accounting_session_timeout
#
# Accounting 'sessions' created by pfbandwidthd (level 3 traffic only) that haven't been updated for more than this
# amount of seconds will be considered inactive.
# This should be higher than the interval at which pfmon runs
# Defaults to 300 - 5 minutes
layer3_accounting_session_timeout = 300
# inline.layer3_accounting_sync_interval
#
# Interval at which pfbandwidthd (level 3 traffic only) should dump collected information into the database.
# This should be lower than the interval at which pfmon runs
# Defaults to 41 seconds
layer3_accounting_sync_interval = 41
#
# inline.ports_redirect
#
# Ports to intercept and redirect for trapped and unregistered systems.  Defaults to 80/tcp (HTTP), 443/tcp (HTTPS).
# Redirecting 443/tcp (SSL) will work, although users might get certificate errors if you didn't install a valid 
# certificate or if you don't use DNS (although IP-based certificates supposedly exist)
# Redirecting 53/udp (DNS) seems to have issues and is also not recommended.
# We also have experimental IMAP and POP3 listeners which give fake emails telling users to open their browsers.
# Enable them via the ports.listeners parameter and add the IMAP (143/tcp) and POP3 (110/tcp) here.
ports_redirect=80/tcp,443/tcp
#
# inline.should_reauth_on_vlan_change
# Should have to reauthenticate the node if it change vlan
should_reauth_on_vlan_change = disabled
#
# inline.interfaceSNAT
# Choose the interface(s) you want to use to enable snat (by default it´s the management interface)
interfaceSNAT=

[captive_portal]
#
# captive_portal.ip_address
#
# The IP address the portal uses in the registration and isolation networks.
# This IP address should point to an IP outside the registration and isolation networks.
# Do not change unless you know what you are doing.
ip_address=66.70.255.147
#
# captive_portal.network_detection
#
# Enable or not the network detection feature after registration
network_detection=enabled
#
# captive_portal.network_detection_ip
#
# This IP is used as the webserver who hosts the common/network-access-detection.gif which is used to detect if network
# access was enabled. 
# It cannot be a domain name since it is used in registration or quarantine where DNS is blackholed.
# It is recommended that you allow your users to reach your packetfence server and put your LAN's PacketFence IP.
# By default we will make this reach PacketFence's website as an easy solution.
#
network_detection_ip = 192.95.20.194
#
# captive_portal.network_detection_initial_delay
#
# This is the amount of time before network connectivity detection is started. 
network_detection_initial_delay = 5s
#
# captive_portal.network_detection_retry_delay
#
# This is the amount of time between network connectivity detection checks.
network_detection_retry_delay = 2s
#
# captive_portal.network_redirect_delay
#
# How long to display the progress bar during trap release. Default value is 
# based on VLAN enforcement techniques. Inline enforcement only users could
# lower the value.
network_redirect_delay = 20s
#
# captive_portal.image_path
#
# This is the path where the gif is on the webserver to detect if the network access
# has been enabled.
image_path = /common/network-access-detection.gif
#
# captive_portal.request_timeout
#
# The amount of seconds before a request times out in the captive portal
request_timeout = 15
#
# captive_portal.loadbalancers_ip
#
# If the captive portal is put behind load-balancer(s) that act at Layer 7 
# (HTTP level) effectively doing reverse proxying then the captive portal no 
# longer sees the IP of the node trying to access the portal. In that case,
# the load-balancers must do SSL offloading and add a X-Forwarded-By header
# in the HTTP traffic they forward to PacketFence. Most do by default. Then
# in this parameter you must specify the IP of the various load balancers.
# This will instruct the captive portal to look for client IPs in the 
# X-Forwarded-For instead of the actual TCP session when it matches an IP
# in the list. Format is a comma separated list of IPs. Note: Apache access
# log format is not changed to automatically log the X-Forwarded-By header.
# Modify conf/httpd.conf.d/captive-portal-common.conf to use 
# loadbalanced_combined instead of combined in CustomLog statement.
loadbalancers_ip=
#
# captive_portal.secure_redirect
#
# If secure_redirect is enabled, the captive portal uses HTTPS when redirecting
# captured clients. This is the default behavior.
secure_redirect=enabled
#
# captive_portal.status_only_on_production
#
# If status_only_on_production is enabled, the /status page will only be available on the
# production network. This is disabled by default
status_only_on_production=disabled
#
# captive_portal.detection_mecanism_bypass
#
# Bypass the captive-portal detection mechanism of some browsers / end-points by proxying the detection request.
detection_mecanism_bypass = disabled
#
# captive_portal.detection_mecanism_urls
#
# Comma-delimited list of URLs known to be used by devices to detect the presence 
# of a captive portal and trigger their captive portal mechanism.
detection_mecanism_urls = http://www.gstatic.com/generate_204,http://clients3.google.com/generate_204,http://www.apple.com/library/test/success,http://connectivitycheck.android.com/generate_204,http://connectivitycheck.gstatic.com/generate_204,http://www.msftncsi.com/ncsi.txt,http://www.appleiphonecell.com,http://captive.apple.com,http://captive.roku.com/ok,http://detectportal.firefox.com/success.txt
#
# captive_portal.wispr_redirection
#
# Enable or disable WISPr redirection capabilities on the captive-portal
wispr_redirection = disabled
#
# captive_portal.rate_limiting
#
# Temporarily deny access to a user that performs too many requests on the captive portal on invalid URLs
rate_limiting = enabled
#
# captive_portal.rate_limiting_threshold
#
# Amount of requests on invalid URLs after which the rate limiting will kick in for this device
rate_limiting_threshold = 48
#
# captive_portal.other_domain_names
#
# Other domain names under which the captive portal responds
other_domain_names=


[advanced]
#
# advanced.api_inactivity_timeout
#
# The inactivity timeout of an API token
# Requires to restart the api-frontend service to be fully effective.
api_inactivity_timeout=15m
#
# advanced.api_max_expiration
#
# The maximum amount of time an API token can be valid
# Requires to restart the api-frontend service to be fully effective.
api_max_expiration=12h
#
# advanced.language
#
# Language choice for the communication with administrators
language=en_US
#
# advanced.admin_csp_security_headers
#
# Enforce Content-Security-Policy (CSP) HTTP response header in the admin interface
#
admin_csp_security_headers=disabled
#
# advanced.portal_csp_security_headers
#
# Enforce Content-Security-Policy (CSP) HTTP response header in the captive portal interface
#
portal_csp_security_headers=enabled
#
# advanced.sso_on_access_reevaluation
#
# Trigger Single-Sign-On (Firewall SSO) on access reevaluation
sso_on_access_reevaluation=disabled
#
# advanced.scan_on_accounting
#
# Trigger scan engines on accounting
scan_on_accounting=disabled
#
# advanced.sso_on_accounting
#
# Trigger Single-Sign-On (Firewall SSO) on accounting
sso_on_accounting=disabled
# advanced.sso_on_dhcp
#
# Trigger Single-Sign-On (Firewall SSO) on dhcp
sso_on_dhcp=enabled
#
# advanced.hash_passwords
#
# The algorithm to use to hash the passwords in the local database.
hash_passwords=bcrypt
#
# advanced.hashing_cost
#
# The cost factor to apply to the password hashing if applicable.
# Currently only applies to bcrypt.
hashing_cost=8
#
# advanced.disable_pf_domain_auth
#
# Disable Active-Directory domain configuration from within PacketFence
disable_pf_domain_auth=disabled
#
# advanced.ldap_attributes
#
# List of LDAP attributes that can be used in the sources configuration
ldap_attributes=uid,cn,sAMAccountName,servicePrincipalName,UserPrincipalName,department,displayName,distinguishedName,givenName,memberOf,sn,eduPersonPrimaryAffiliation,mail,postOfficeBox,description,groupMembership,basedn
#
# advanced.pffilter_processes
#
# Amount of pffilter processes to start
pffilter_processes=4
#
# advanced.pfperl_api_processes
#
# Amount of pfperl-api processes to start
pfperl_api_processes=8
#
# advanced.update_iplog_with_accounting
#
# Use the information included in the accounting to update the iplog
update_iplog_with_accounting=disabled
#
# advanced.update_iplog_with_external_portal_requests
#
# Use the information included in the accounting to update the iplog
update_iplog_with_external_portal_requests=enabled
#
# advanced.locationlog_close_on_accounting_stop
#
# Close the locationlog for a node on accounting stop
locationlog_close_on_accounting_stop=enabled
#
# advanced.timing_stats_level
#
# Level of timing stats to keep - 0 is the lowest - 10 the highest amount to log
# Do not change unless you know what you are doing
timing_stats_level=5
#
# advanced.source_to_send_sms_when_creating_users
#
# The source to use to send an SMS when creating a user
source_to_send_sms_when_creating_users=
#
# advanced.multihost
#
# Ability to manage all active devices from a same switch port
multihost=disabled
#
# active_directory_os_join_check_bypass
#
# Enable to bypass the operating system domain join verification.
active_directory_os_join_check_bypass=disabled
# advanced.statsd_listen_port
#
# The port where statsd listen
statsd_listen_port = 8125

# advanced.pfperl_api_timeout
#
# Execution timeout for pfperl-api
pfperl_api_timeout = 600

# advanced.configurator
#
# Enable the Configurator and the Configurator API
configurator = enabled

# advanced.netflow_on_all_networks
#
# Listen to netflow on all networks
netflow_on_all_networks = disabled

# advanced.accounting_timebucket_size
#
# Accounting timebucket size
accounting_timebucket_size = 5m

# advanced.openid_attributes
#
# List of known OpenID Attributes
openid_attributes=

[provisioning]
#
# provisioning.autoconfig
#
# Enable or disable the XML mobile config generation for wireless on iPhones, iPods, and iPads
autoconfig = disabled

#
# provisioning.ssid
#
# SSID name where the users need to connect to upon registration
ssid = SSID-Hidden

#
# provisioning.category
#
# Accessible to node that are member of this category
category = any

#
# provisioning.certificate
#
# Certificate to send to the node
certificate = 

[node_import]
#
# node_import.pid
#
# Default pid value to assign to imported nodes.
pid=default
#
# node_import.category
#
# Default category to assign to imported nodes.
category=default
#
# node_import.voip
#
# By default is an imported node a Voice over IP device or not?
voip=no

[webservices]
#
# webservices.user
#
# username to use to connect to the webAPI
user =
#
# webservices.pass
#
# password of the username
pass =
#
# webservices.host
#
# host of the webAPI
host=127.0.0.1
#
# webservices.proto
#
# proto to use
proto=http
#
# webservices.port
#
# port to use
port=9090
#
# webservices.aaa_port
#
# port to use for authentication
aaa_port=7070
#
# webservices.unifiedapi_port
#
# port to use for accessing the Unified API
unifiedapi_port=9999

[active_active]
#
# active_active.password
#
# Shared KEY for vrrp protocol (Must be the same on all members).
password=1234
#
# active_active.virtual_router_id
#
# Shared KEY for vrrp protocol (Must be the same on all members).
virtual_router_id=50
#
# active_active.vrrp_unicast
#
# Enable keepalived in unicast mode instead of multicast
vrrp_unicast=disabled
#
# active_active.dns_on_vip_only
#
# Set the name server option in DHCP replies to point only to the VIP in cluster mode rather than to all servers in the cluster.
dns_on_vip_only=disabled
#
# active_active.centralized_deauth
#
# Centralize the deauthentication to the management node of the cluster.
centralized_deauth=enabled
#
# active_active.portal_on_management
#
# Process captive portal requests on the management server (the current load balancer).
# Disabling it will make the management server only proxy requests to other servers.
# Useful if your load balancer cannot handle both tasks.
# Changing this requires to restart the haproxy-portal service.
portal_on_management=enabled
#
# active_active.auth_on_management
#
# Process RADIUS authentication requests on the management server (the current load balancer).
# Disabling it will make the management server only proxy requests to other servers.
# Useful if your load balancer cannot handle both tasks.
# Changing this requires to restart radiusd.
auth_on_management=enabled
#
# active_active.conflict_resolution_threshold
#
# Defines the amount of seconds after which pfmon attempts to resolve a configuration version conflict between cluster members.
# For example, if this is set to 5 minutes, then a resolution will be attempted when the members will be detected running a different version for more than 5 minutes.
conflict_resolution_threshold=5m
#
# active_active.galera_replication
#
# Whether or not to activate galera cluster when using a cluster
galera_replication=enabled
#
# active_active.galera_replication_username
#
# Defines the replication username to be used for the MariaDB Galera cluster replication
galera_replication_username=
#
# active_active.galera_replication_password
#
# Defines the replication password to be used for the MariaDB Galera cluster replication
galera_replication_password=

[parking]
#
# parking.lease_length
#
# Lease length (in seconds) when a device is in parking
lease_length=3600
#
# parking.lease_length
#
# The threshold (in seconds) after which a device will be placed in parking
# A value of 0 deactivates the parking detection.
# The detection works by looking at the time in seconds a device has been in the registration role and comparing it with this threshold
threshold=0
#
# parking.place_in_dhcp_parking_group
#
# Place the device in the DHCP parking group when it is detected doing parking
place_in_dhcp_parking_group=enabled
#
# parking.show_parking_portal
#
# Show the parking portal to the device instead of the usual portal
show_parking_portal=enabled

[mse_tab]
#
# mse_tab.enabled
#
# Enabled MSE tab
enabled=disabled
#
# mse_tab.url
#
# URL of MSE server
url=
#
# mse_tab.user
#
# Username of MSE server
user=
#
# mse_tab.pass
#
# Password of MSE server
pass=

[radius_configuration]
#
# radius_configuration.record_accounting_in_sql
#
# Record the accounting data in the SQL tables.
# Requires a restart of radiusd to be effective.
record_accounting_in_sql=enabled
#
# advanced.filter_in_packetfence_authorize
#
# Send the radius request in the radius filter from the radius packetfence.authorize section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_authorize=disabled
#
# radius_configuration.filter_in_packetfence_pre_proxy
#
# Send the radius request in the radius filter from the radius packetfence.pre_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_pre_proxy=disabled
#
# radius_configuration.filter_in_packetfence_post_proxy
#
# Send the radius request in the radius filter from the radius packetfence.post_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_post_proxy=disabled
#
# radius_configuration.filter_in_packetfence_preacct
#
# Send the radius request in the radius filter from the radius packetfence.preacct section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_preacct=disabled
#
# radius_configuration.filter_in_packetfence_accounting
#
# Send the radius request in the radius filter from the radius packetfence.accounting section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence_accounting=disabled
#
# radius_configuration.filter_in_packetfence-tunnel_authorize
#
# Send the radius request in the radius filter from the radius packetfence-tunnel.authorize section.
# Requires a restart of radiusd to be effective.
filter_in_packetfence-tunnel_authorize=disabled
#
# advanced.filter_in_eduroam_authorize
#
# Send the radius request in the radius filter from the radius eduroam.authorize section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_authorize=disabled
#
# radius_configuration.filter_in_eduroam_pre_proxy
#
# Send the radius request in the radius filter from the radius eduroam.pre_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_pre_proxy=disabled
#
# radius_configuration.filter_in_eduroam_post_proxy
#
# Send the radius request in the radius filter from the radius eduroam.post_proxy section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_post_proxy=disabled
#
# radius_configuration.filter_in_eduroam_preacct
#
# Send the radius request in the radius filter from the radius eduroam.preacct section.
# Requires a restart of radiusd to be effective.
filter_in_eduroam_preacct=disabled
#
# radius_configuration.ntlm_redis_cache
#
# Enables a Redis driven cache for NTLM authentication. 
# In order for this to work, you need to setup proper NT hash syncronization between your PacketFence server and your AD.
# Refer to the Administration guide for more details.
# Applying this requires a restart of radiusd.
ntlm_redis_cache=disabled
#
# radius_configuration.radius_attributes
#
# List of RADIUS attributes that can be used in the sources configuration
radius_attributes=User-Name,username,NAS-Identifier,Called-Station-Id,Calling-Station-Id
#
# radius_configuration.normalize_radius_machine_auth_username
#
# Normalize the radius machine auth username
normalize_radius_machine_auth_username=disabled
#
# radius_configuration.username_attributes
#
# Which attributes to use to get the username from a RADIUS request
# The order of the attributes are listed in this configuration parameter is followed while performing the lookup
username_attributes=PacketFence-UserNameAttribute,TLS-Client-Cert-Subject-Alt-Name-Upn,TLS-Client-Cert-Common-Name,User-Name
# radius_configuration.forward_key_balanced
#
# Send in the proxy request the attribute PacketFence-KeyBalanced to randomize the load balance in the next PacketFence RADIUS server
forward_key_balanced=disabled

[dns_configuration]
#
# dns_configuration.record_dns_in_sql
#
# Record dns requests and replies in SQL table
record_dns_in_sql=disabled

[pfdhcp]
#
# pfdhcp.ip2mac_lookup
#
# Use the Unified API to query pfdhcp for the MAC address of a given IP address
ip2mac_lookup=disabled
#
# pfdhcp.mac2ip_lookup
#
# Use the Unified API to query pfdhcp for the IP address of a given MAC address
mac2ip_lookup=disabled
#
# pfdhcp.connect_timeout_ms
#
# Timeout (in milliseconds) to connect to the Unified API when performing queries
connect_timeout_ms=200
#
# pfdhcp.timeout_ms
#
# Timeout (in milliseconds) when performing queries to the Unified API
timeout_ms=200

[fingerbank_device_change]
# 
# fingerbank_device_change.enable
#
# Whether or not the Fingerbank device change feature is enabled
enable=disabled

#
# fingerbank_device_change.trigger_on_device_class_change
#
# Whether or not internal::fingerbank_device_change should be triggered when we detect a device class change in Fingerbank
trigger_on_device_class_change=enabled

#
# fingerbank_device_change.device_class_whitelist
# 
# Which device class changes are allowed in conjunction with trigger_on_device_class_change
# Comma delimited transitions using the following format: $PREVIOUS_DEVICE_CLASS_ID->$NEW_DEVICE_CLASS_ID where $PREVIOUS_DEVICE_CLASS_ID and $NEW_DEVICE_CLASS_ID are the IDs in the Fingerbank database.
device_class_whitelist=

#
# fingerbank_device_change.triggers
#
# Which changes (changing from a device class to another) should trigger internal::fingerbank_device_change
# This setting is independant from trigger_on_device_class_change and allows to specify exactly which transitions should trigger internal::fingerbank_device_change
# Comma delimited transitions using the following format: $PREVIOUS_DEVICE_CLASS_ID->$NEW_DEVICE_CLASS_ID where $PREVIOUS_DEVICE_CLASS_ID and $NEW_DEVICE_CLASS_ID are the IDs in the Fingerbank database.
triggers=

[lets_encrypt]
#
# lets_encrypt.radius
# Whether or not Let's Encrypt should be enabled for RADIUS certificate management
radius=disabled
#
# lets_encrypt.http
# Whether or not Let's Encrypt should be enabled for HTTP certificate management
http=disabled
#
# lets_encrypt.live
# Whether or not Let's Encrypt should be using the live ACME API. Set to disabled only for testing since the certificates that will be issued will not be valid.
live=enabled
#
# lets_encrypt.test_uri
# The URI to use to test that the portal is available publicly
test_uri=https://ssl-test.inverse.ca/
