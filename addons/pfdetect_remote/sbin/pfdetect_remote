#!/usr/bin/perl

=head1 NAME

pfdetect-remote - listen to violations alerts and send them to PF server

=head1 SYNOPSIS

pfdetect -p <file | named pipe> -e <ENGINE>  [options]

  Options:
    -d  Daemonize
    -h  Help

  ENGINE is one of : snort, tippingp or trend

=cut

use Getopt::Std;
use File::Basename;
use File::Tail;
use FileHandle;
use POSIX qw(:signal_h);
use SOAP::Lite;
use Sys::Syslog;
use Config::IniFiles;
use Data::Dumper;
use Pod::Usage;
use strict;
use warnings;

POSIX::sigaction(
    &POSIX::SIGHUP,
    POSIX::SigAction->new(
        'restart_handler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGHUP handler: $!\n";

POSIX::sigaction(
    &POSIX::SIGTERM,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGTERM handler: $!\n";

POSIX::sigaction(
    &POSIX::SIGINT,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGINT handler: $!\n";


my @ORIG_ARGV = @ARGV;
my %args;
getopts( 'c:dhvp:e:', \%args );
pod2usage( -verbose => 1 ) if ( $args{h} );

openlog( "pfdetect_remote", '', 'auth' );
syslog( "info", "initialized" );

my $install_dir = defined $args{c} ? 
                  $args{c} : 
                  '/usr/local/pf';
my $cfg         = new Config::IniFiles( -file => "$install_dir/conf/pfdetect_remote.conf" );
my $daemonize   = $args{d};
my $ADMIN_USER  = $cfg->val( 'server', 'user' );
my $ADMIN_PWD   = $cfg->val( 'server', 'password' );
my $PF_HOST     = $cfg->val( 'server', 'host' );
my $ENGINE      = defined $args{e} ?
                  $args{e} :
                  $cfg->val( 'trapping', 'detection_engine' );
my $SOURCE      = defined $args{p} ? 
                  $args{p} : 
                  $cfg->val( 'trapping', 'alert_source' );   # input can be from either a logfile or a pipe
my $script      = File::Basename::basename($0);

daemonize() if ($daemonize);

my $fh = new File::Tail(
    'name'        => $SOURCE,
    'interval'    => 2,
    'reset_tail'  => 0,
    'maxinterval' => 2
);
syslog( "info", "listening on $SOURCE" );

# A dispatch table where the key is the type of event to parse
# and the value is a ref to the appropriate sub for the type.
my $parse_alert_for = {
    snort    => \&parse_snort_alert,
    tippingp => \&parse_tippingp_alert,
    trend    => \&parse_trend_alert,
};

my $currentLine;
READALERT:
while ( defined( $currentLine = $fh->read ) ) {

    syslog( "info", "alert received: $currentLine" );

    my %event;
    %event = $parse_alert_for->{$ENGINE}->($currentLine);
    if ( !defined( $event{"event_id"} ) or $event{"event_id"} eq "unknown" ) {
        syslog( "warning", "unknown input: $currentLine " );
        next READALERT;
    }

    eval {
        my $soap = new SOAP::Lite(
            uri   => 'http://www.packetfence.org/PFAPI',
            proxy => 'https://'
              . $ADMIN_USER . ':'
              . $ADMIN_PWD . '@'
              . $PF_HOST
              . '/webapi'
        );
        my $result =
          $soap->event_add( $event{"date"}, $event{"srcip"}, "detect",
            $event{"event_id"} );
        if ( $result->fault ) {
            syslog( "warning",
                    "violation could not be added: "
                  . $result->faultcode . " - "
                  . $result->faultstring . " - "
                  . $result->faultdetail );
        }
        else {
            syslog( "info",
                qq(added violation $event{"event_id"} for $event{"srcip"}) );
        }
    };
    if ($@) {
        syslog( "warning", "connection to $PF_HOST with username $ADMIN_USER was NOT successful: $@");
        next READALERT;
    }

}

END {
    deletepid();
    syslog( "info", "stopping pfdetect_remote" );
}

exit(0);

=pod

=head1 Subroutines:

=cut 

sub daemonize {
    chdir '/' or die "Can't chdir to /: $!";
    open STDIN,  '<', '/dev/null' or die "Can't read /dev/null: $!";
    open STDOUT, '>', '/dev/null' or die "Can't write to /dev/null: $!";

    defined( my $pid = fork ) or die "pfdetect_remote: could not fork: $!";
    POSIX::_exit(0) if ($pid);
    if ( !POSIX::setsid() ) {
        syslog( "warning", "could not start a new session: $!" );
    }
    open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
    createpid();
    return 1;
}

sub normal_sighandler {
    deletepid();
    syslog( "info", "caught SIG" . $_[0] . " - terminating pfdetect_remote" );
    die( "pfdetect_remote: caught SIG" . $_[0] . " - terminating\n" );
}

sub restart_handler {
    deletepid();
    syslog( "info", "caught SIG" . $_[0] . " - restarting pfdetect_remote" );
    if ( !exec( $0, @ORIG_ARGV ) ) {
        syslog( "warning", "could not restart: #!" );
        die "pfdetect_remote: could not restart: $!\n";
    }
}

sub createpid {
    my $pname   = basename($0);
    my $pid     = $$;
    my $pidfile = $install_dir . "/var/$pname.pid";
    syslog( "info", "$pname starting and writing $pid to $pidfile" );
    my $outfile = new FileHandle ">$pidfile";
    if ( defined($outfile) ) {
        print $outfile $pid;
        $outfile->close;
        return ($pid);
    }
    else {
        syslog( "warning", "$pname: unable to open $pidfile for writing: $!" );
        return (-1);
    }
}

sub deletepid {
    my ($pname) = @_;
    $pname = basename($0) if ( !$pname );
    my $pidfile = $install_dir . "/var/$pname.pid";
    unlink($pidfile) || return (-1);
    return (1);
}

=pod

=head2 parse_snort_alert 
This sub will parse a line from a snort event and fill in the %event hash;

=cut 

sub parse_snort_alert {
    my $currentLine  = shift;
    my $portscan_sid = 1200003;    # portscan is a special case
    my %event;

    my $syslog_prefix = qr/              # used when reading from syslog
        ( \S{2,3} \s+ \S+ \s \S+ ) \s+   # $1 is MM DD HH:MM:SS
        \w+ \s snort\[ \d+ \] : \s+      # typically something like "centos6 snort[pid]:"
    /x;

    my $fifo_prefix = qr/                # used when reading from snort fifo
        (\S+)  \s+                       # $1 is the date
        \[\*\*\] \s+                     # a litteral [**]
    /x;

    # a regex that matches any snort alert.
    my $snort_line = qr/
        ^
        (?: $syslog_prefix | $fifo_prefix )             # $1 matches the date based on the input type
        \[\d+: (\d+): \d+\] \s+                         # $2 is snort id :  [ gid : $2 : rev ] 
        ( .+ ) $                                        # $3 is description, src and dst ips
    /x;

    # most snort alerts match this (except for portscans)
    my $snort_details = qr/
        ^
        .+?
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) \s+        # $1 is src ip 
        \-\>   \s+                                      # ->
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})            # $2 is dst ip
    /x;

    # snort portscans match this one.
    my $portscan = qr/
        Portscan\s+detected\s+from\s+                   
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})            # $1 is the $srcip
    /x;

    # we match the part of the snort line that is common to all snort alert and
    # keep the remainder for the second step.
    my ( $syslog_date, $fifo_date, $event_id, $remainder ) = $currentLine =~  /$snort_line/;

    # date will be defined either in syslog_date or fifo_date depending on input type.
    $event{"date"} = defined $syslog_date ? $syslog_date : $fifo_date;
    $event{"event_id"} = $event_id;

    # then we match again on the remainder, trying in turn every type of alert.
    if ( ( my $srcip ) = $remainder =~ $portscan ) {
        @event{qw( srcip event_id )} = ( $srcip, $portscan_sid );
    }
    elsif ( @event{qw( srcip dstip )} = $remainder =~ $snort_details ) {
    }
    else {
        syslog( "warning", "unknown input: $currentLine " );
        $event{"event_id"} = "unknown";
    }

    return %event;
}

=pod

=head2 parse_tippingp_alert 
This sub will parse a line from a Tipping Point event and fill in the %event hash;

=cut 

sub parse_tippingp_alert {
    my $currentLine = shift;
    my %event;

    my $tippingp_alert = qr/
        ^(.+?)\s+                               # $1 is date
        \b \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}   # an ip 
        \sALT\;v\d\;                            # ALT;v${VERSION};
    /x;

    ( $event{"date"} ) = $currentLine =~ $tippingp_alert;
    my @hpValues = split( ';', $currentLine );

    ( @event{qw(event_id  descr)} ) = $hpValues[10] =~ /(\d+)\:\s(.*)\"$/;
    @event{qw( srcip dstip )} = @hpValues[ 13, 15 ];

    return %event;
}

=pod

=head2 parse_trend_alert 
This sub will parse a line from a Trend Micro event and fill in the %event hash;

=cut 

sub parse_trend_alert {
    chomp( my $currentLine = shift );
    my %event;

    my $trend_date = qr/
        ^ 
        (\w+ \s+            # Month
        \d+ \s+             # Day
        \d+:\d+:\d+) \s     # HH:MM:SS  $1 is the whole date
    /x;

    my $trend_srcip = qr/
        \s+ malSrcIp= 
        ( \d+\.\d+\.\d+\.\d+ ) \s   # $1 is an IP 
    /x;

    # trend alert is pipe separated
    my @fields = ( split( /\|/, $currentLine ) )[ 0, 4, 7 ];  # we ignore irrelevant fields
    ( $event{"date"} )  = ( $fields[0] =~ $trend_date ); 
    $event{"event_id"}  = $fields[1];
    ( $event{"srcip"} ) = ($fields[2] =~ $trend_srcip) ;

    return %event;
}

=head1 AUTHOR

Dave Laporte <dave@laportestyle.org>

Kevin Amorin <kev@amorin.org>

Dominik Gehl <dgehl@inverse.ca>

Louis Munro  <lmunro@inverse.ca>

=head1 COPYRIGHT

Copyright (C) 2005 Dave Laporte

Copyright (C) 2005 Kevin Amorin

Copyright (C) 2006-2009 Inverse inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

# vim: set shiftwidth=4:
# vim: set expandtab:
# vim: set backspace=indent,eol,start:
